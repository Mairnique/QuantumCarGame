Index: app/src/main/java/com/chumaribelle/quantumcargame/GameView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.chumaribelle.quantumcargame;\r\n\r\nimport android.content.Context;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.BitmapFactory;\r\nimport android.graphics.Canvas;\r\nimport android.graphics.Color;\r\nimport android.graphics.Paint;\r\nimport android.graphics.Path;\r\nimport android.graphics.RectF;\r\nimport android.graphics.Region;\r\nimport android.graphics.Typeface;\r\nimport android.util.AttributeSet;\r\nimport android.view.MotionEvent;\r\nimport android.view.SurfaceHolder;\r\nimport android.view.SurfaceView;\r\nimport android.widget.ProgressBar;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.core.content.res.ResourcesCompat;\r\n\r\nimport java.util.ArrayList;\r\n\r\npublic class GameView extends SurfaceView implements Runnable{\r\n\r\n    public static final double MAX_UPS = 30.0;\r\n\r\n    private SurfaceHolder mSurfaceHolder;\r\n    Context mContext;\r\n    private int mViewWidth;\r\n    private int mViewHeight;\r\n    private CarSprite mCar;\r\n    private Bitmap carBitmap;\r\n    private SuperpositionCar superCar;\r\n    private boolean mRunning;\r\n    private Thread mGameThread;\r\n    private Paint mPaint;\r\n    private Path mPath;\r\n    private Joystick mJoystick;\r\n    private RectF mBoundary;\r\n    private float position;\r\n    // decoherence variables\r\n    private DecoherenceSprite mDecoherence;\r\n    private float lastDecoPosition;\r\n    private Bitmap decoBitmap;\r\n    private ArrayList<DecoherenceSprite> decoArray;\r\n    private int speed;\r\n    private int decoWidth;\r\n    // probability variables\r\n    private Bitmap probBitmap;\r\n    private ArrayList<ProbabilitySprite> probArray;\r\n    private int probWidth;\r\n    // collisions\r\n    private int probTotal;\r\n    private int dProb;\r\n    private float decoScreenStartTime;\r\n    private float timeSinceDecoScreen;\r\n    // finish line\r\n    private Bitmap finBitmap;\r\n    private FinishLineSprite finSprite;\r\n    private int finLinePos;\r\n\r\n    private boolean inSuperposition;\r\n    private long superpositionStart;\r\n    private long timeSinceSuperStart;\r\n    private boolean createSuperposition;\r\n\r\n    private boolean createMeasurement;\r\n    private long measurementStart;\r\n    private long timeSinceMeasureStart;\r\n    private boolean rewindBool;\r\n    private Bitmap rewindBitmap;\r\n    private Bitmap staticBitmap;\r\n    private int posIncrement;\r\n\r\n    private RectF emptyProgress;\r\n    private RectF filledProgress;\r\n    private float measurePos;\r\n\r\n    int intervalNum = 0;\r\n    private float rewindStart;\r\n    private float timeSinceRewindStart;\r\n    private int decoTime;\r\n    private boolean decoScreenOn;\r\n\r\n\r\n    public GameView(Context context) {\r\n        super(context);\r\n        init(context);\r\n    }\r\n\r\n    public GameView(Context context, AttributeSet attrs) {\r\n        super(context, attrs);\r\n        init(context);\r\n    }\r\n\r\n    public GameView(Context context, AttributeSet attrs, int defStyleAttr) {\r\n        super(context, attrs, defStyleAttr);\r\n        init(context);\r\n        mSurfaceHolder = getHolder();\r\n    }\r\n\r\n    public void init(Context context) {\r\n        mContext = context;\r\n        mSurfaceHolder = getHolder();\r\n        setFocusable(true);\r\n        mPaint = new Paint();\r\n    }\r\n\r\n    @Override\r\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\r\n        super.onSizeChanged(w, h, oldw, oldh);\r\n        mViewWidth = w;\r\n        mViewHeight = h;\r\n        speed = -10;\r\n        decoWidth = (int) (mViewWidth/18);\r\n        probWidth = (int) (mViewWidth/20);\r\n        probTotal = 50;\r\n        dProb = 10;\r\n        finLinePos = 100000;\r\n        posIncrement = speed*-1;\r\n        decoTime = 2;\r\n\r\n        // car bitmap\r\n        carBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.futureracecar);\r\n        carBitmap = Bitmap.createScaledBitmap(carBitmap, (int) (mViewWidth/9.5), (int) (mViewHeight/12.5), false);\r\n        mCar = new CarSprite(20, (mViewHeight/2)-(carBitmap.getHeight()/2), 20+carBitmap.getWidth(),\r\n                (mViewHeight/2)+(carBitmap.getHeight()/2), 0, 0, carBitmap);\r\n        mJoystick = new Joystick(200, mViewHeight-200, 150, 40);\r\n        mBoundary = new RectF(0,\r\n                mViewHeight/7,\r\n                mViewWidth,\r\n                mViewHeight*6/7);\r\n\r\n        // Decoherence Setup\r\n        decoBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.decoherence);\r\n        decoBitmap = Bitmap.createScaledBitmap(decoBitmap, decoWidth, decoWidth, false);\r\n        decoArray = new ArrayList<>();\r\n\r\n        // Probability Setup\r\n        probBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.probability);\r\n        probBitmap = Bitmap.createScaledBitmap(probBitmap, probWidth, probWidth, false);\r\n        probArray = new ArrayList<>();\r\n\r\n        // Finish Line Setup\r\n        finBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.finishline);\r\n        finBitmap = Bitmap.createScaledBitmap(finBitmap, mViewWidth / 8, mViewHeight, false);\r\n        finSprite = new FinishLineSprite(mViewWidth - mViewWidth / 8, 0, mViewWidth, mViewHeight, speed, Color.RED, finBitmap);\r\n\r\n        inSuperposition = false;\r\n\r\n        // Rewind Image\r\n        rewindBitmap =  BitmapFactory.decodeResource(mContext.getResources(), R.drawable.rewind);\r\n        rewindBitmap = Bitmap.createScaledBitmap(rewindBitmap, mViewWidth/8, mViewHeight/8, false);\r\n\r\n        // Static Image\r\n        staticBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.staticimage);\r\n        staticBitmap = Bitmap.createScaledBitmap(staticBitmap, mViewWidth, mViewHeight, false);\r\n\r\n        // Progress Bar\r\n        emptyProgress = new RectF((float) mViewWidth/32, (float) mViewHeight/32, (float) mViewWidth*10/16, (float) mViewHeight/8);\r\n        filledProgress = new RectF(emptyProgress.left+5, emptyProgress.top+5, emptyProgress.left+5, emptyProgress.bottom-5);\r\n    }\r\n\r\n    public void pause() {\r\n        mRunning = false;\r\n        try {\r\n            // Stop the thread (rejoin the main thread)\r\n            mGameThread.join();\r\n        } catch (InterruptedException e) {\r\n        }\r\n    }\r\n\r\n    public void resume() {\r\n        mRunning = true;\r\n        mGameThread = new Thread(this);\r\n        mGameThread.start();\r\n    }\r\n\r\n    public boolean onTouchEvent(MotionEvent event) {\r\n\r\n        switch(event.getAction()) {\r\n            case MotionEvent.ACTION_DOWN:\r\n                mJoystick = new Joystick((int) event.getX(), (int) event.getY(), 120, 60);\r\n                if(mJoystick.isPressed(event.getX(), event.getY())) {\r\n                    mJoystick.setIsPressed(true);\r\n                }\r\n                return true;\r\n            case MotionEvent.ACTION_MOVE:\r\n                if(mJoystick.getIsPressed()) {\r\n                    mJoystick.setStick(event.getX(), event.getY());\r\n                }\r\n                return true;\r\n            case MotionEvent.ACTION_UP:\r\n                mJoystick.setIsPressed(false);\r\n                mJoystick.resetStick();\r\n                return true;\r\n        }\r\n        return super.onTouchEvent(event);\r\n    }\r\n\r\n    public void drawBackground(Canvas canvas) {\r\n        // Grass\r\n        mPaint.setColor(Color.rgb(113, 245, 252));\r\n        canvas.drawRect(0,0,mViewWidth,(float) mViewHeight/7, mPaint);\r\n        canvas.drawRect(0, (float) mViewHeight*6/7, mViewWidth, mViewHeight, mPaint);\r\n\r\n        // Road\r\n        mPaint.setColor(Color.rgb(53, 53, 53));\r\n        canvas.drawRect(0, (float) mViewHeight/7, mViewWidth, (float) mViewHeight*6/7, mPaint);\r\n\r\n        // Lane Markers\r\n        mPaint.setColor(Color.WHITE);\r\n        for(int i=2; i<6; i++) {\r\n            float top = (float) mViewHeight/7*i-5;\r\n            float bottom = top+10;\r\n            for(int j=0; j<=10; j++) {\r\n                float left = (float) mViewWidth/10*j + (float) mViewWidth/20;\r\n                float right = left+25;\r\n                canvas.drawRect(left, top, right, bottom, mPaint);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void generateDecoherenceProbability(Canvas canvas) {\r\n        int y = 0;\r\n        for (int i = 0; i < 5; i++){\r\n            y += mViewHeight/7;\r\n            if (inSuperposition) {\r\n                if (Math.random() * 50 < 6) {\r\n                    DecoherenceSprite deco = new DecoherenceSprite(mViewWidth, y, mViewWidth + decoWidth, y + decoWidth, speed, Color.RED, decoBitmap);\r\n                    decoArray.add(deco); // saved decoherence to array\r\n                    deco.drawDecoherence(canvas);\r\n                }\r\n                else if (Math.random() * 50 < 6) {\r\n                    ProbabilitySprite prob = new ProbabilitySprite(mViewWidth,y ,mViewWidth + probWidth,y + probWidth,speed, Color.RED, probBitmap);\r\n                    probArray.add(prob); // saved decoherence to array\r\n                    prob.drawProbability(canvas);\r\n                }\r\n            }\r\n            else if (Math.random() * 50 < 6) {\r\n                DecoherenceSprite deco = new DecoherenceSprite(mViewWidth, y, mViewWidth + decoWidth, y + decoWidth, speed, Color.RED, decoBitmap);\r\n                decoArray.add(deco); // saved decoherence to array\r\n                deco.drawDecoherence(canvas);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void decoScreen(Canvas canvas, float decoScreenStartTime){\r\n        Paint p = new Paint();\r\n        float timeSinceDecoStart = (System.nanoTime() - decoScreenStartTime)/1000000000;\r\n        if (timeSinceDecoStart < 1)\r\n            p.setAlpha((int) (timeSinceDecoStart*255));\r\n        if (timeSinceDecoStart > decoTime-1)\r\n            p.setAlpha((int) ((decoTime-timeSinceDecoStart)*255));\r\n        canvas.drawBitmap(staticBitmap,0,0, p);\r\n    }\r\n\r\n    private void superposition(Canvas canvas, Paint text) {\r\n        timeSinceSuperStart = System.nanoTime() - superpositionStart;\r\n        int secondsVal = (3 - (int) (timeSinceSuperStart/1000000000));\r\n\r\n        String superString = \"\";\r\n        superString = \"Superposition in \" + secondsVal;\r\n\r\n        canvas.drawText(superString, (float) mViewWidth *11/16, 100, text);\r\n        if (secondsVal <= 0) {\r\n            createSuperposition = false;\r\n            inSuperposition = true;\r\n            superCar = new SuperpositionCar(mCar, speed, carBitmap, position);\r\n        }\r\n    }\r\n\r\n    private void rewind(Canvas canvas, Paint alphaPaint) {\r\n        mJoystick.setIsPressed(false);\r\n        posIncrement = 0;\r\n        timeSinceRewindStart = System.nanoTime() - rewindStart;\r\n        int secondsVal = (3 - (int) (timeSinceRewindStart/1000000000));\r\n        int tempIntervalNum = (int) timeSinceRewindStart / 1000000;\r\n        float superCarPos = superCar.pos;\r\n        if (position > superCarPos && tempIntervalNum > intervalNum) {\r\n            position = position - ((tempIntervalNum-intervalNum)*((measurePos - superCarPos) / 3) / 1000);\r\n            intervalNum = tempIntervalNum;\r\n        }\r\n        // Static\r\n        canvas.drawBitmap(staticBitmap, 0, 0, alphaPaint);\r\n        if (secondsVal%2 != 0)\r\n            canvas.drawBitmap(rewindBitmap, (float) mViewWidth/2-(float)rewindBitmap.getWidth()/2, (float) mViewHeight/2-(float)rewindBitmap.getHeight()/2, new Paint());\r\n        if (secondsVal <= 0) {\r\n            posIncrement = speed*-1;\r\n            probTotal = 50;\r\n            rewindBool = false;\r\n            mCar = new CarSprite(20, (int) superCar.top, 20+carBitmap.getWidth(), (int) superCar.bottom,0 ,0, carBitmap);\r\n            position = superCarPos;\r\n            lastDecoPosition = position;\r\n        }\r\n    }\r\n\r\n    private void measure(Canvas canvas, Paint text) {\r\n        timeSinceMeasureStart = System.nanoTime() - measurementStart;\r\n        int secondsVal = (3 - (int) (timeSinceMeasureStart/1000000000));\r\n\r\n        String measureString = \"\";\r\n        measureString = \"Measurement in \" + secondsVal;\r\n\r\n\r\n        canvas.drawText(measureString, (float) mViewWidth *11/16, 100, text);\r\n\r\n        if (secondsVal <= 0) {\r\n            createMeasurement = false;\r\n            inSuperposition = false;\r\n            double measurement = Math.random() * 100;\r\n            if (measurement < probTotal) {\r\n                if (decoArray.size() > 0) {\r\n                    decoArray.subList(0, decoArray.size()).clear();\r\n                }\r\n            }\r\n            else {\r\n                measurePos = position;\r\n                rewindBool = true;\r\n                rewindStart = System.nanoTime();\r\n            }\r\n            probTotal = 50;\r\n            probArray.subList(0, probArray.size()).clear();\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public void run() {\r\n        // Variables\r\n        Canvas canvas;\r\n        long frameStartTime;\r\n        long frameTime;\r\n        final int FPS = 60;\r\n        Paint text = new Paint();\r\n        text.setTextSize(55);\r\n        Typeface typeface = ResourcesCompat.getFont(mContext, R.font.goldman_bold);\r\n        text.setTypeface(typeface);\r\n        text.setTextAlign(Paint.Align.LEFT);\r\n\r\n\r\n        Paint alphaPaint = new Paint();\r\n        alphaPaint.setAlpha(60);\r\n\r\n        Paint empty = new Paint();\r\n        empty.setStyle(Paint.Style.STROKE);\r\n        empty.setStrokeWidth(5);\r\n\r\n        Paint filled = new Paint();\r\n\r\n        // Running stuff\r\n        while(mRunning) {\r\n            if (mSurfaceHolder.getSurface().isValid()) {\r\n                this.position += posIncrement; // update position\r\n//                System.out.println(\"Current Position: \" + position);\r\n                // record start time for run\r\n                frameStartTime = System.nanoTime();\r\n\r\n                canvas = mSurfaceHolder.lockCanvas();\r\n                canvas.save();\r\n\r\n                drawBackground(canvas);\r\n\r\n                mCar.draw(canvas);\r\n                mCar.update(mJoystick, mBoundary);\r\n\r\n                if(inSuperposition && superCar.inBounds) {\r\n                    superCar.draw(canvas);\r\n                    superCar.update(mBoundary);\r\n                }\r\n\r\n                if(mJoystick.getIsPressed()) {\r\n                    mJoystick.draw(canvas);\r\n                    mJoystick.update();\r\n                }\r\n\r\n\r\n                // Decoherence\r\n                for (int i = decoArray.size() - 1; i >= 0; i--){\r\n                    decoArray.get(i).drawDecoherence(canvas);\r\n                    if (!decoArray.get(i).updateOk(canvas)){\r\n                        decoArray.remove(i);\r\n                    }\r\n                    // if car intersects decoherence, delete decoherence and make screen white with static\r\n                    else if ((decoArray.get(i)).intersect(mCar)){\r\n//                        decoScreen(canvas, position); // draw the deco screen\r\n                        decoArray.remove(i);\r\n                        posIncrement = 2;\r\n                        if (inSuperposition) {\r\n                            if (probTotal > 40)\r\n                                probTotal = ((int) (Math.random()*5))*10;\r\n                            else\r\n                                probTotal = ((int) (Math.random()*(probTotal/10)))*10;\r\n                        }\r\n                        if (decoScreenOn)\r\n                            decoTime += 0.5;\r\n                        else {\r\n                            decoScreenOn = true;\r\n                            decoScreenStartTime = System.nanoTime();\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Probability tokens\r\n                for (int i = probArray.size() - 1; i >= 0; i--){\r\n                    probArray.get(i).drawProbability(canvas);\r\n                    if (!probArray.get(i).updateOk(canvas)){\r\n                        probArray.remove(i);\r\n                    }\r\n                    // probability collide with car, delete it and add to probTotal\r\n                    else if ((probArray.get(i)).intersect(mCar)){\r\n                        probArray.remove(i);\r\n                        if (probTotal < 100)\r\n                            probTotal += dProb;\r\n                    }\r\n                }\r\n\r\n\r\n                // Deco Screen\r\n                if ((System.nanoTime() - decoScreenStartTime)/1000000000 < decoTime && !rewindBool) {\r\n                    decoScreen(canvas, decoScreenStartTime);\r\n                }\r\n                if ((System.nanoTime() - decoScreenStartTime)/1000000000 > decoTime && !rewindBool) {\r\n                    posIncrement = -1*speed;\r\n                    decoTime = 2;\r\n                    decoScreenOn = false;\r\n                }\r\n\r\n                // each 10 frames\r\n                if (position - lastDecoPosition > decoWidth) {\r\n                    if (Math.random() * 50 < 4 && !(position > finLinePos) && !rewindBool){\r\n                        generateDecoherenceProbability(canvas);\r\n                        lastDecoPosition = position;\r\n                    }\r\n                }\r\n\r\n\r\n                // Updating superposition\r\n\r\n                if (position - lastDecoPosition > decoWidth && !createSuperposition && !inSuperposition) {\r\n                    double superRand = (Math.random() * 400);\r\n                    if (superRand < 1) {\r\n                        createSuperposition = true; // Determine whether to create superposition\r\n                        superpositionStart = System.nanoTime();\r\n                    }\r\n                }\r\n                if (createSuperposition && !inSuperposition) {\r\n                    superposition(canvas, text);\r\n                }\r\n\r\n                // Measurement\r\n\r\n                if (position - lastDecoPosition > decoWidth && !createMeasurement && inSuperposition) {\r\n                    double measureRand = (Math.random() * 500);\r\n                    if (measureRand < 1) {\r\n                        createMeasurement = true; // Determine whether to create superposition\r\n                        measurementStart = System.nanoTime();\r\n                    }\r\n                }\r\n\r\n                if (createMeasurement && inSuperposition) {\r\n                    measure(canvas, text);\r\n                }\r\n\r\n                // Rewind\r\n                if(rewindBool) {\r\n                    rewind(canvas, alphaPaint);\r\n                }\r\n\r\n\r\n                if (position > finLinePos) {\r\n                    finSprite.drawFinishLine(canvas);\r\n                    finSprite.updateOk(canvas);\r\n\r\n//                    if (position > finLinePos + mViewWidth) {\r\n                    finSprite.drawFinishLineScreen(canvas, mViewWidth, mViewHeight);\r\n//                    }\r\n                }\r\n\r\n\r\n                // Draw Progress\r\n                float progress = (float) position / finLinePos * (emptyProgress.width()-10);\r\n                filledProgress.right = filledProgress.left + progress;\r\n                canvas.drawRect(emptyProgress, empty);\r\n                canvas.drawRect(filledProgress, filled);\r\n\r\n                if (inSuperposition) {\r\n                    canvas.drawText(\"Probability of clear: \" + probTotal, (float) mViewWidth*1/32, (float) mViewHeight*15/16, text);\r\n                    canvas.drawText(\"Probability of reset to split: \" + (100-probTotal), (float) mViewWidth*8/16, (float) mViewHeight*15/16, text);\r\n                }\r\n\r\n\r\n                canvas.restore();\r\n                mSurfaceHolder.unlockCanvasAndPost(canvas);\r\n\r\n                frameTime = (System.nanoTime() - frameStartTime) / 1000000;\r\n\r\n                if (frameTime < (1000/FPS)) // if faster than the FPS -> wait until FPS matched\r\n                {\r\n                    try {\r\n                        Thread.sleep((int)(1000/FPS) - frameTime);\r\n                    } catch (InterruptedException e) {}\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/chumaribelle/quantumcargame/GameView.java b/app/src/main/java/com/chumaribelle/quantumcargame/GameView.java
--- a/app/src/main/java/com/chumaribelle/quantumcargame/GameView.java	(revision 4ccd4d9ebac0ab8301433351a22099f8c7cb8764)
+++ b/app/src/main/java/com/chumaribelle/quantumcargame/GameView.java	(date 1674661795807)
@@ -439,7 +439,7 @@
                 // Updating superposition
 
                 if (position - lastDecoPosition > decoWidth && !createSuperposition && !inSuperposition) {
-                    double superRand = (Math.random() * 400);
+                    double superRand = (Math.random() * 300);
                     if (superRand < 1) {
                         createSuperposition = true; // Determine whether to create superposition
                         superpositionStart = System.nanoTime();
